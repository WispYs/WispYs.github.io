<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[文本溢出显示省略号 ( - ... - )]]></title>
      <url>%2F2017%2F04%2F29%2F%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%20(%20-%20...%20-%20)%2F</url>
      <content type="text"><![CDATA[现在来介绍一下我们今天的嘉宾：阿伦 · 特雷西 · 克里斯蒂亚诺 · … 省略号，在汉语中的基本形式是位于中线的六个小圆点（……），占两个字的位置；我国传统习惯在书面上用“上略”“下略”等表示省略，鲁迅1909年在《域外小说集·略例》中提出四种新式标点符号，其中“虚线”即省略号表示“语不尽”或“语中辍”，1930年《教育部划一教育机关公文格式办法》定名为“省略号”，沿用至今。16世纪英国的剧本出现省略号，表示话语被打断，或不完整。俄语语法著作1831年第一次提到省略号（…）大尉/船长。西方语文的省略号位于底线。英语句首或句中词语的省略用三个小圆点（…）表示 。 欧克，打完收工！ 开个玩笑，作为一只专业的前端程序猿怎么可能会如此敷衍行事 。OK，今天我们就来探讨一下文本溢出显示省略号的问题 。 文本溢出显示省略号单行自不多说 1234width: 200px;overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 我们来重点探讨一下多行文本溢出省略 Round 1 对于 Webkit 内核浏览器可以使用 WebKit 的 CSS 扩展属性 -webkit-line-clamp 。值得注意的是 -webkit-line-clamp 是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 该属性可以限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他外来的WebKit属性。 常见结合属性： 1. display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 2. -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 3. text-overflow，可以用来多行文本的情况下，用省略号“...”隐藏超出范围的文本 。 123456//用法overflow : hidden;text-overflow: ellipsis;display: -webkit-box; -webkit-line-clamp: 3; //限制在一个块元素显示的文本行数最多2行-webkit-box-orient: vertical; 效果如下： 但是，这毕竟是 Webkit 特有的属性，绕不开兼容性问题 。 所以 -webkit-line-clamp ，OUT！ Round 2 既然考虑到兼容性的写法，那我们能不能用 伪类 定位的方法模拟省略号呢？ 123456789101112p::after&#123; content: ""; text-align: right; position: absolute; bottom: 0; right: 0; width: 50%; height: 1.2em; background: -webkit-linear-gradient(left, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1) 50%); background: -o-linear-gradient(left, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1) 50%); background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1) 50%);&#125; 这里用到了背景颜色过渡在结尾处由透明到白色来遮盖原来的文字，效果如下： 可以看到实际效果还可以，但是考虑到背景如果是带颜色的或者是图片就不太好处理了 。 SO 伪类，OUT！ Round 3 既然自己无法解决，那么看看别人是怎么处理的吧 。Clamp.js 是一个处理此问题的 JS 插件，在 GitHub 上有上千颗星，(¯﹃¯) Let’s Do It ! 在一系列的完（chao）美（xi）操（wen）作（dang）后，终于实现了原先的需求 。其原理也十分简单易懂，先判断浏览器是否支持 webkitLineClamp 属性（ typeof(element.style.webkitLineClamp) ），支持就添加该属性用 css 控制，不支持就用递归的方式递减文本，然后判断其高度是否超过规定的最大高度 。但是值得注意的是，使用 Clamp.js 后不能定义该元素的 height，只能通过其原有方法（ $clamp(myParagraph, {clamp: &#39;35px&#39;}) ）限制元素高度，不然会影响其内部的判断从而导致个别浏览器报错 。 Mission Complete！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 姬与 CSS3 动画不得不说的故事]]></title>
      <url>%2F2017%2F04%2F25%2FAndroid%20%E5%A7%AC%E4%B8%8E%20CSS3%20%E5%8A%A8%E7%94%BB%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[最近公司做一个H5抽奖活动，要求将中奖名单（？？不存在的）显示在页面中，效果类似直播平台的弹幕一样飘过 。心想简单啊，直接定位用animate动画就解决了，然而… 问题来了，问题来了，问题来了！在测试的时候，发现部分安卓机型出现卡卡卡卡顿的现象，实际动画效果引起强烈不适，有一种撸多了的感觉…Android 姬妮怎么老是出问题呀(╯‵□′)╯︵┻━┻ 。 经过一番周折，两遁空门，叁叁来迟，似李狗贼终于让我找见了解决卡顿的方法 。 方案： 尽量使用 transform 当成动画处理，避免使用 height,width,margin,padding 等； 要求较高时，可以开启浏览器开启GPU硬件加速 webkit-transform: translate3d( 0,0,0 ); -moz-transform: translate3d( 0,0,0 ); -ms-transform: translate3d( 0,0,0 ); -o-transform: translate3d( 0,0,0 ); transform: translate3d( 0,0,0 ); 那到底是为什么 Android 姬会出现卡顿的现象呢？为什么亲儿子 IOS 没有受到遗传呢？这后面究竟是道德的伦桑还是人性的扭曲？欢迎收看《 走进科学 - Android 下的C3动画》。 令人吃鲸的真相从浏览器的引擎工作原理方面 深入浏览器理解 CSS animations 和 transitions 的性能问题 一文中提到，现代的浏览器通常会有两个重要的执行线程，这2个线程协同工作来渲染一个网页：主线程和合成线程 。 一般情况下，主线程负责： 运行 JavaScript 计算 HTML 元素的 CSS 样式。 页面的布局 将元素绘制到一个或多个位图中 将这些位图交给合成线程 相应地，合成线程负责： 通过 GPU 将位图绘制到屏幕上 通知主线程更新页面中可见或即将变成可见的部分的位图 计算出页面中哪部分是可见的 计算出当你在滚动页面时哪部分是即将变成可见的 当你滚动页面时将相应位置的元素移动到可视区域 使用 height,width,margin,padding,top,left 占用主线程比较耗时。而使用 transform 浏览器只需要一次生成这个元素的位图，并在动画开始的时候将它提交给GPU去处理 。 通过DevTools从文档对象模型到像素级别的观察 下图是 Chrome 浏览器中动画的 timeline，瀑布流越高，浏览器为了计算每个像素，就做的越多。 由此也能验证以上得出的结论 。 文章 High Performance Animations 提到： We’re going to cut straight to the chase. Modern browsers can animate four things really cheaply: position, scale, rotation and opacity. If you animate anything else, it’s at your own risk, and the chances are you’re not going to hit a silky smooth 60fps. 现代浏览器在完成 position，scale，rotation，opacity 四种属性的动画时，消耗成本较低 。 捉急的项目证实为了验证以上的理论，我将两种写法做了比对 。 下图是我之前的方法，使用定位改变 right 的值使元素从右到左移动，但是可以看到这种写法的 FPS 平均只有 30 。我们知道每秒 60 帧是最适合人眼交互的，FPS 小于 60 人眼能明显感觉的到，这就是为什么卡顿的原因 。 下图使用了 transform 方法改变 translateX 的值，FPS 明显高过 60 帧 ，惊不惊喜？ 意不意外？ 总结为了做到兼容性好，流畅度高的动画，一定要对自己的代码做好优化，尽可能将动画元素absolute化以避免影响文档树，造成大面积重新计算layout 。动画处理使用浏览器渲染快的 transform 属性，尽量避免改变 height,width,margin,padding 等，要求较高时还可以开启浏览器 GPU 硬件加速（ transform: translate3d( 0,0,0 ) ） 。 PS：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一劳永逸的搞定 flex 布局（转）]]></title>
      <url>%2F2017%2F04%2F19%2F%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E7%9A%84%E6%90%9E%E5%AE%9A-flex-%E5%B8%83%E5%B1%80%EF%BC%88%E8%BD%AC%EF%BC%89%2F</url>
      <content type="text"><![CDATA[寻根溯源话布局一切都始于这样一个问题：怎样通过 CSS 简单而优雅的实现水平、垂直同时居中。记得刚开始学习 CSS 的时候，看到 float 属性不由得感觉眼前一亮，顺理成章的联想到 Word 文档排版中用到的的左对齐、右对齐和居中对齐，然而很快就失望的发现 CSS 中并不存在 float: center 的写法，那么 text-align: center、verticle-align: center 是否可行呢？答案也是否定的。这两个属性只能用于行内元素，对于块级元素的布局是无效的。 在网页布局没有进入 CSS 的时代，排版几乎是通过 table 元素实现的，在 table 的单元格里可以方便的使用 align、valign 来实现水平和垂直方向的对齐，随着 Web 语义化的流行，这些写法逐渐淡出了视野，CSS 标准为我们提供了 3 种布局方式：标准文档流、浮动布局和定位布局。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求，比如实现水平居中可以使用 margin: 0 auto，实现水平垂直同时居中可以如下设置：123.dad &#123; position: relative;&#125; 12345678.son &#123; position: absolute; margin: auto; top: 0; right: 0; bottom: 0; left: 0;&#125; 123.dad &#123; position: relative;&#125; 123456789.son &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px;&#125; 然而，这些写法都存在一些缺陷：缺少语义并且不够灵活。我们需要的是通过 1 个属性就能优雅的实现子元素居中或均匀分布，甚至可以随着窗口缩放自动适应。在这样的需求下，CSS 的第 4 种布局方式诞生了，这就是我们今天要重点介绍的 flex 布局。 flex 基本概念使用 flex 布局首先要设置父容器 display: flex，然后再设置 justify-content: center 实现水平居中，最后设置 align-items: center 实现垂直居中。12345#dad &#123; display: flex; justify-content: center; align-items: center&#125; 就是这么简单，大功告成。等等，好像哪里不对，justify-content 和 align-items 是啥？哪里可以看出横向、竖向的语义？是的，flex 的确没有那么简单，这就要从两个基本概念说起了。 说来也不难，flex 的核心的概念就是 容器 和 轴。容器包括外层的 父容器 和内层的 子容器，轴包括 主轴 和 交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含 display: flex），其中父容器、子容器各 6 个。不过常用的属性只有 4 个，父容器、子容器各 2 个，我们就先从常用的说起吧。 1. 容器 容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。 1.1 父容器 设置子容器沿主轴排列：justify-content justify-content 属性用于定义如何沿着主轴方向排列子容器。 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。 space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。 设置子容器如何沿交叉轴排列：align-items align-items 属性用于定义如何沿着交叉轴方向分配子容器的间距。 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 baseline：基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。 stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。 1.2 子容器 在主轴上如何伸缩：flex 子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 `flex`` 属性确定。 flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。 虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。 单独设置子容器如何沿交叉轴排列：align-self 每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 align-items 属性完全一致，如果两者同时设置则以子容器的 align-self 属性为准。 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 baseline：基线对齐 stretch：拉伸对齐 2. 轴 如图所示，轴 包括 主轴 和 交叉轴，我们知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定。 主轴 主轴的起始端由 flex-start表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。 向右：flex-direction: row 向下：flex-direction: column 向左：flex-direction: row-reverse 向上：flex-direction: column-reverse 交叉轴 主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 flex-start 和 flex-end 表示。 上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。 flex 进阶概念1. 父容器 设置换行方式：flex-wrap 决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。 nowrap：不换行 wrap：换行 wrap-reverse：逆序换行 逆序换行是指沿着交叉轴的反方向换行。 轴向与换行组合设置：flex-flow flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如 flex-flow: row wrap，flex-flow 是一个复合属性，相当于flex-direction 与 flex-wrap 的组合，可选的取值如下： row、column等，可单独设置主轴方向 wrap、nowrap 等，可单独设置换行方式 row nowrap、column wrap 等，也可两者同时设置 多行沿交叉轴对齐：align-content 当子容器多行排列时，设置行与行之间的对齐方式 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 space-around：等边距均匀分布 space-between：等间距均匀分布 stretch：拉伸对齐 2. 子容器 设置基准大小：flex-basis flex-basis 表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。 设置扩展比例：flex-grow 子容器弹性伸展的比例。如图，剩余空间按 1:2 的比例分配给子容器。 设置收缩比例：flex-shrink 子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。 设置排列顺序：order 改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。 以上就是 flex 布局的全部属性，一共 12 个，父容器、子容器各 6 个，可以随时通过下图进行回顾。 转载：原文地址 https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-js-文档学习记录（三）- 条件、列表和事件]]></title>
      <url>%2F2017%2F01%2F20%2FVue-js-%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89-%E6%9D%A1%E4%BB%B6%E3%80%81%E5%88%97%E8%A1%A8%E5%92%8C%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[条件渲染1. v-if 控制元素是否渲染1&lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt; 也可以用 v-else 添加一个 “else” 块，v-else 元素必须紧跟在 v-if 元素或者 v-else-if的后面——否则它不能被识别。123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Sorry&lt;/div&gt;&lt;div v-else&gt; Not sorry&lt;/div&gt; 2. v-else-if 顾名思义，用作 v-if 的 else-if 块。可以链式的多次使用：123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 3. v-show 控制元素是否显示1&lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt; 4. v-if 与 v-show 的不同 v-if 是真实的条件才会渲染，如果初始条件是假的则不会做任何处理，只有在条件第一次变为真时才开始局部编译 v-show 的元素会始终渲染并保持在 DOM 中，v-show 是简单的切换元素的 CSS 属性 display 。 一般来说， v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。 列表渲染v-for 指令根据一组数组的选项列表进行渲染 基本用法12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; v-for 还支持一个可选的第二个参数为当前项的索引。12345&lt;ul id="example-2"&gt; &lt;li v-for="(item, index) in items"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：1&lt;div v-for="item of items"&gt;&lt;/div&gt; Template 如同 v-if 模板，你也可以用带有 v-for 的 标签来渲染多个元素块。例如：123456&lt;ul&gt; &lt;template v-for="item in items"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 范围 v-for 也可以取整数。在这种情况下，它将重复多次模板。123&lt;div&gt; &lt;span v-for="n in 10"&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;&lt;/div&gt; 事件处理器v-on 指令监听 DOM 元素出发事件，可简写成1&lt;div @click="handleClick"&gt;&lt;/div&gt; //v-on:click 可简写成 @click 有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法：1&lt;li @click="handleClick( $event )"&gt;&lt;/li&gt; 事件修饰符 v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。1234567891011121314151617181920&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 按键修饰符 12345678&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-js-文档学习记录（二）- 数据绑定]]></title>
      <url>%2F2017%2F01%2F17%2FVue-js-%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89-%20%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
      <content type="text"><![CDATA[插值1.插入文本 双括号插值法“Mustache” 语法（双大括号）1&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; v-once 指令能执行一次性地插值，当数据改变时，插值处的内容不会更新1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 2.插入纯 HTML v-html 指令能输出真正的 HTML1&lt;div v-html="vHtml"&gt;&lt;/div&gt; 3.绑定属性 v-bind 指令绑定元素属性1&lt;div v-bind:id="uId"&gt;&lt;/div&gt; 4.使用 JavaScript 表达式 可以使用 JavaScript 表达式数据绑定1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt; 指令1.参数 一些指令能接受一个“参数”，在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：12&lt;a v-bind:href="url"&gt;&lt;/a&gt; //href 就是v-bind 的参数，给元素绑定href 属性&lt;a v-on:click="doSomething"&gt; //click 也是参数 2.过滤器 Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示：1234567891011121314以下实现绑定的数据首字母大写&#123;&#123; message | capitalize &#125;&#125;new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 3.缩写 v-bind 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;&lt;/a&gt; v-on 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;&lt;/a&gt; Class 与 Style 绑定绑定Class常用绑定 v-bind :class 可简写 :class，并且和原有的 class 不冲突1&lt;div :class="className"&gt;&lt;/div&gt; 对象绑定1&lt;div :class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; //isActive为真值 绑定active 三目运算符1&lt;div :class=" followed ? 'btn-success' : 'btn-failure' "&gt;&lt;/div&gt; 绑定Stylev-bind :style 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式或短横分隔命名：123456&lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;data: &#123; activeColor: 'red', fontSize: 30&#125; 直接绑定到一个样式对象通常更好，让模板更清晰：12345678&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 计算属性computed 函数处理复杂逻辑的计算，计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter12345678910111213141516171819202122var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取，值只须为函数 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // -&gt; 2vm.aPlus = 3vm.a // -&gt; 2vm.aDouble // -&gt; 4 监听数据WatchVue 提供一个通用的方法通过, watch 选项来响应数据的变化。12345watch: &#123; Amount: function (val, oldVal) &#123; this.getChange() // 如果 Amount 发生改变，这个函数就会运行 &#125; &#125;,]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js 文档学习记录（一）- 安装和基础]]></title>
      <url>%2F2017%2F01%2F16%2FVue-js-%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89-%20%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[前言 要谈到现在的前端框架，称为React，Angular，Vue 三分天下丝毫不过分，其中Vue凭借他简单的API、高效的数据绑定和灵活的组件系统独占一方天地。廉价的学习成本也成为吸引我的重要因素（快把这个懒货抓起来！）。 作为国人研发的框架，文档自然也是中文，我蹩脚的英语终于可以歇歇了，再次感谢尤大。让我们来看看Vue的文档是怎么介绍自己的： “ Vue.js 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。” 关于 渐进式框架 和 自底向上增量 的理解，我在知乎上找见一些回答 Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？，个人初步理解是Vue的设计不会强制你按照它的机制，你可以在原有的系统上，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的绑定数据。我们可以根据需求，利用社区良好的生态，借助已有的工具和库搭建我们的项目，用最小、最快的成本一步步完成。 安装直接 script 引入1&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt; NPM1$ npm install vue 脚手架Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：123456789$ npm install --global vue-cli //全局安装 vue-cli$ vue init webpack my-project //创建一个基于 webpack 模板的新项目$ cd my-project //进入创建文件$ npm install //安装依赖$ npm run dev //走你 发车声明式渲染数据渲染123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) 属性绑定123&lt;div id="app-2"&gt; &lt;img v-bind:src="imgSrc" /&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; imgSrc: './img/banner.jpg' &#125;&#125;) 条件与循环v-if 指令控制切换一个元素的显示/隐藏：123div id="app-3"&gt; &lt;p v-if="seen"&gt;Now you see me&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) v-for 指令可以绑定数据到数组来渲染一个列表：1234567&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="list in lists"&gt; &#123;&#123; list.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; lists: [ &#123; text: 'Eat' &#125;, &#123; text: 'Sleep' &#125;, &#123; text: 'Dota' &#125; ] &#125;&#125;) 处理用户输入v-on 指令绑定一个监听事件123&lt;div id="app-5"&gt; &lt;button v-on:click="handleClick"&gt;&#123;&#123;message&#125;&#125;&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: '按钮' &#125;, methods: &#123; handleClick () &#123; ... &#125; &#125;&#125;) v-model 指令使得在表单输入和应用状态中做双向数据绑定变得非常轻巧1234&lt;div id="app-6"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: 'Hello Vue!' &#125;&#125;) 开发组件在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例：1234Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;'&#125;) 然后就可以使用你定义的组件12345678910111213141516&lt;div id="app-7"&gt; &lt;ol&gt; &lt;todo-item v-for="item in todo" v-bind:todo="item"&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt;var app7 = new Vue(&#123; el: '#app-7', data: &#123; todo: [ &#123; text: 'AM' &#125;, &#123; text: 'BM' &#125;, &#123; text: 'CM' &#125; ] &#125;&#125;) 但是在项目中通常不会这样写，会把一个个组件单独写在.vue文件中，举个栗子： todoItem.vue 12345678910111213141516171819...&lt;template&gt; &lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; &#125; &#125;, props: ['todo'],&#125;&lt;/script&gt;&lt;style&gt; ...&lt;/style&gt; app.vue 12345678910111213141516171819202122232425...&lt;template&gt; &lt;ol&gt; &lt;todo-item v-for="item in todo" :todo='item'&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/template&gt;&lt;script&gt;import todoItem from './components/todoItem'export default &#123; data () &#123; return &#123; todo: [ &#123; text: 'AM' &#125;, &#123; text: 'BM' &#125;, &#123; text: 'CM' &#125; ] &#125; &#125;, components: &#123; todoItem, ... &#125;&#125;&lt;/script&gt; 怎么样是不是觉得这样写很爽快，OK 你成功的上道了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用Git命令]]></title>
      <url>%2F2017%2F01%2F14%2F%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[一、全局配置 Git 的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。1234567$ git config --list //显示当前的Git配置$ git config -e [--global] //编辑Git配置文件$ git config [--global] user.name "[name]" //设置提交代码时的用户名字$ git config [--global] user.email "[email address]" //设置提交代码时的用户地址 二、创建 SSH Key 由于本地的 Git 仓库和 Github 仓库之间的传输是通过 SSH 加密。在用户的主目录下，看看有没有 .ssh 目录，如果有，再看看目录下有没有 id_rsa 和 id_rsa.pub 文件，id_rsa.pub文件的内容就是 Key， 如果已经有了，可直接跳到下一步。没有则：1ssh-keygen -t rsa -C "xxxxxx@xx.com" 三、创建版本库123456$ git init //在当前目录新建一个Git代码库 //此时当前目录下多了一个.git的目录，这个目录是来跟踪管理版本库的。 $ git init [project-name] //新建一个目录，将其初始化为Git代码库$ git clone [url] //下载一个项目和它的整个代码历史 四、远程库 添加后远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道远程库。123456789101112131415161718192021$ git remote add origin git@github.com:sid/learngit.git //把本地的仓库和刚刚创建的Github仓库关联$ git clone git@github.com:sid/gitskills.git // 克隆远程库$ git remote rm origin // 删除远程库origin$ git fetch [remote] // 下载远程仓库的所有变动$ git remote -v // 显示所有远程仓库$ git remote show [remote] // 显示某个远程仓库的信息$ git remote add [shortname] [url] // 增加一个新的远程仓库，并命名$ git pull [remote] [branch] // 取回远程仓库的变化，并与本地分支合并$ git push [remote] [branch] // 上传本地指定分支到远程仓库$ git push [remote] --force // 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --all //推送所有分支到远程仓库 五、添加/删除文件1234567$ git add README.md //添加指定文件到暂存区$ git add -A //添加当前目录的所有文件到暂存区$ git rm README.md //删除工作区文件，并且将这次删除放入暂存区$ git mv [file-original] [file-renamed] //改名文件，并且将这个改名放入暂存区 六、代码提交12345678910111213141516171819202122$ git commit -m 'first commit' //提交暂存区到仓库区$ git commit -a //提交工作区自上次commit之后的变化，直接到仓库区$ git commit -v //提交时显示所有diff信息$ git commit --amend -m [message] //使用一次新的commit，替代上一次提交 //如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend [file1] [file2] //重做上一次commit，并包括指定文件的新变化``` 七、撤销修改---```bash$ git checkout [file] // 恢复暂存区的指定文件到工作区$ git checkout . // 恢复暂存区的所有文件到工作区 $ git reset [file] // 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset --hard // 重置暂存区与工作区，与上一次commit保持一致 八、分支1234567891011$ git branch // 列出所有本地分支$ git branch -r // 列出所有远程分支$ git branch -a // 列出所有本地分支和远程分支$ git branch [branch-name] // 新建一个分支，但依然停留在当前分支$ git checkout -b [branch] // 新建一个分支，并切换到该分支$ git merge [branch] // 合并指定分支到当前分支 九、查看信息123456789$ git status // 显示有变更的文件$ git log // 显示当前分支的版本历史$ git log --stat // 显示commit历史，以及每次commit发生变更的文件$ git diff //显示暂存区和工作区的差异$ git diff HEAD // 显示工作区与当前分支最新commit之间的差异]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript 6 学习笔记（三）：字符串、正则和数值的扩展]]></title>
      <url>%2F2016%2F12%2F25%2FECMAScript-6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%AD%A3%E5%88%99%E5%92%8C%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[字符串1.repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整。 1234'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'dota'.repeat(0) // ""'dota'.repeat(2.9) // "dotadota" 2.模板字符串 模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，变量名写在${}之中。 12345678`I sure $&#123;name&#125; is a good boy`$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 3.padStart()，padEnd() 字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 正则RegExp构造函数 ES512var regex = new RegExp('xyz', 'i');var regex = new RegExp(/xyz/i); ES6123var regex = /xyz/i;new RegExp(/abc/ig, 'i').flags// "i" 原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 数值1.Number.isFinite(), Number.isNaN() ES6 在 Number 对象上，新提供了 Number.isFinite() 和 Number.isNaN() 两个方法。Number.isFinite()用来检查一个数值是否为有限的（finite） 1234Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // false Number.isNaN()用来检查一个值是否为 NaN。1234Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // false 2.Number.parseInt(), Number.parseFloat() ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 3.Number.isInteger() Number.isInteger()用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值。 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger("15") // falseNumber.isInteger(true) // false 4.Math 对象的扩展 Math.trunc() Math.trunc方法用于去除一个数的小数部分，返回整数部分。 1234567Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc('123.456') // 123 对于非数值，Math.trunc内部使用Number方法将其先转为数值。Math.trunc('foo'); // NaN 对于空值和无法截取整数的值，返回NaN。 Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零。 它会返回五种值。 参数为正数，返回+1；参数为负数，返回-1；参数为0，返回0；参数为-0，返回-0;其他值，返回NaN。1234567Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign('foo'); // NaNMath.sign(); // NaN Math.cbrt() Math.cbrt方法用于计算一个数的立方根。 123456Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734Math.cbrt('8') // 2 对于非数值，Math.cbrt内部使用Number方法将其先转为数值。Math.cbrt('hello') // NaN 对于空值和无法截取整数的值，返回NaN。 5.指数运算符 ES2016 新增了一个指数运算符（**）。 122 ** 2 // 42 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript 6 学习笔记（二）：变量的解构赋值]]></title>
      <url>%2F2016%2F12%2F25%2FECMAScript-6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[1. 数组的解构赋值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 基本用法 ES6 可以从数组中提取值，按照对应位置，对变量赋值。1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。12345let [foo, [[bar], baz]] = [1, [[2], 3]]; // foo = 1 bar = 2 baz = 3let [ , , third] = ["foo", "bar", "baz"]; // third = "baz"let [x, , y] = [1, 2, 3]; // x = 1 y = 3 默认值 解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 2. 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 3. 字符串的解构赋值123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 4. 用途 交换变量的值123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript 6 学习笔记（一）：let / const 命令]]></title>
      <url>%2F2016%2F12%2F24%2FECMAScript-6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Alet-const-%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[前言 现在 ES6 已经非常普及了，基本上前端新出的框架都用上了ES6的语法。作为新兴时代的前端，如果你还对 ES6 不了解那就真的过分了，兄弟们赶紧撸起袖子搞起来吧！附上阮一峰写的书 ECMAScript 6 入门 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言 ECMAScript 和 JavaScript 的关系 ECMAScript 是 Javascript 的规范，Javascript 是 ECMAScript 的实现 声明的新方式 let / const 使用ES6，我们需要全面使用let/const替换var，我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量，也可以称之为常量。 1. let 不同于 var，let 声明的变量只在 let 命令所在的代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 for 循环的计数器，就很合适使用let命令 下面的代码使用 var 声明 i，console 里面的 i 是全局声明的，会随着循环而变化最后为 10，使得 a[0] , a[1] … a[9] 函数里面的 i 都是 10，所以最后 a6 结果也是 10 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 而使用 let 声明的变量仅在块级作用域内有效，如下，当前的 i 只在本轮循环有效，所以每一次 console 的 i 其实都是一个新的变量，所以输出是 6 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 let 不存在变量提升 var 声明的变量，可以在声明之前使用，值为undefind而 let 声明的变量一定要在声明后使用，否则报错1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'dota'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 不允许重复声明12345678910111213141516171819function () &#123; let a = 10; var a = 1;// 报错&#125;function () &#123; let a = 10; let a = 1;// 报错&#125;function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 2. 块级作用域 ES512345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; // if代码块内var变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 &#125;&#125;f(); // undefined ES61234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; // if代码块内声明了新的n变量，外层代码块不受内层代码块的影响 &#125; console.log(n); // 5&#125; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 3. const const声明一个只读的常量。一旦声明，常量的值就不能改变。123const COUNT = 10COUNT = 11;console.log(COUNT) //Uncaught TypeError: Assignment to constant variable. 对于const来说，只声明不赋值，就会报错。12const foo;// SyntaxError: Missing initializer in const declaration const 声明与 let 基本相同 只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升 同样存在暂时性死区，只能在声明的位置后面使用。 const声明的常量，也与let一样不可重复声明。 const本质 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心 12345678910111213141516const foo = &#123;&#125;;// 可以为 foo 添加一个属性foo.prop = 123;foo.prop // 123// 但是如果将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-onlyconst a = [];a.push("1")console.log(a) // ["1"]const a = [];a = [1,2,3]console.log(a) // 报错 4. 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 ES6一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。12345var a = 1;window.a // 1let b = 1;window.b // undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cmd Markdown 编辑阅读器]]></title>
      <url>%2F2016%2F12%2F14%2FCmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
      <content type="text"><![CDATA[我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
    </entry>

    
  
  
</search>
