<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Vue.js 文档学习记录（一）]]></title>
      <url>%2F2017%2F01%2F16%2FVue-js-%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[前言 要谈到现在的前端框架，称为React，Angular，Vue 三分天下丝毫不过分，其中Vue凭借他简单的API、高效的数据绑定和灵活的组件系统独占一方天地。廉价的学习成本也成为吸引我的重要因素（快把这个懒货抓起来！）。 作为国人研发的框架，文档自然也是中文，我蹩脚的英语终于可以歇歇了，再次感谢尤大。让我们来看看Vue的文档是怎么介绍自己的： “ Vue.js 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。” 关于 渐进式框架 和 自底向上增量 的理解，我在知乎上找见一些回答 Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？，个人初步理解是Vue的设计不会强制你按照它的机制，你可以在原有的系统上，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的绑定数据。我们可以根据需求，利用社区良好的生态，借助已有的工具和库搭建我们的项目，用最小、最快的成本一步步完成。 安装直接 script 引入1&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt; NPM1$ npm install vue 脚手架Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：123456789$ npm install --global vue-cli //全局安装 vue-cli$ vue init webpack my-project //创建一个基于 webpack 模板的新项目$ cd my-project //进入创建文件$ npm install //安装依赖$ npm run dev //走你 发车声明式渲染数据渲染123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) 属性绑定123&lt;div id="app-2"&gt; &lt;img v-bind:src="imgSrc" /&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; imgSrc: './img/banner.jpg' &#125;&#125;) 条件与循环v-if 指令控制切换一个元素的显示/隐藏：123div id="app-3"&gt; &lt;p v-if="seen"&gt;Now you see me&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) v-for 指令可以绑定数据到数组来渲染一个列表：1234567&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="list in lists"&gt; &#123;&#123; list.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; lists: [ &#123; text: 'Eat' &#125;, &#123; text: 'Sleep' &#125;, &#123; text: 'Dota' &#125; ] &#125;&#125;) 处理用户输入v-on 指令绑定一个监听事件123&lt;div id="app-5"&gt; &lt;button v-on:click="handleClick"&gt;&#123;&#123;message&#125;&#125;&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: '按钮' &#125;, methods: &#123; handleClick () &#123; ... &#125; &#125;&#125;) v-model 指令使得在表单输入和应用状态中做双向数据绑定变得非常轻巧1234&lt;div id="app-6"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: 'Hello Vue!' &#125;&#125;) 开发组件在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例：1234Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;'&#125;) 然后就可以使用你定义的组件12345678910111213141516&lt;div id="app-7"&gt; &lt;ol&gt; &lt;todo-item v-for="item in todo" v-bind:todo="item"&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt;var app7 = new Vue(&#123; el: '#app-7', data: &#123; todo: [ &#123; text: 'AM' &#125;, &#123; text: 'BM' &#125;, &#123; text: 'CM' &#125; ] &#125;&#125;) 但是在项目中通常不会这样写，会把一个个组件单独写在.vue文件中，举个栗子： todoItem.vue 12345678910111213141516171819...&lt;template&gt; &lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; &#125; &#125;, props: ['todo'],&#125;&lt;/script&gt;&lt;style&gt; ...&lt;/style&gt; app.vue 12345678910111213141516171819202122232425...&lt;template&gt; &lt;ol&gt; &lt;todo-item v-for="item in todo" :todo='item'&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/template&gt;&lt;script&gt;import todoItem from './components/todoItem'export default &#123; data () &#123; return &#123; todo: [ &#123; text: 'AM' &#125;, &#123; text: 'BM' &#125;, &#123; text: 'CM' &#125; ] &#125; &#125;, components: &#123; todoItem, ... &#125;&#125;&lt;/script&gt; 怎么样是不是觉得这样写很爽快，OK 你成功的上道了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用Git命令]]></title>
      <url>%2F2017%2F01%2F14%2F%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[一、全局配置 Git 的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。1234567$ git config --list //显示当前的Git配置$ git config -e [--global] //编辑Git配置文件$ git config [--global] user.name "[name]" //设置提交代码时的用户名字$ git config [--global] user.email "[email address]" //设置提交代码时的用户地址 二、创建 SSH Key 由于本地的 Git 仓库和 Github 仓库之间的传输是通过 SSH 加密。在用户的主目录下，看看有没有 .ssh 目录，如果有，再看看目录下有没有 id_rsa 和 id_rsa.pub 文件，id_rsa.pub文件的内容就是 Key， 如果已经有了，可直接跳到下一步。没有则：1ssh-keygen -t rsa -C "xxxxxx@xx.com" 三、创建版本库123456$ git init //在当前目录新建一个Git代码库 //此时当前目录下多了一个.git的目录，这个目录是来跟踪管理版本库的。 $ git init [project-name] //新建一个目录，将其初始化为Git代码库$ git clone [url] //下载一个项目和它的整个代码历史 四、远程库 添加后远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道远程库。123456789101112131415161718192021$ git remote add origin git@github.com:sid/learngit.git //把本地的仓库和刚刚创建的Github仓库关联$ git clone git@github.com:sid/gitskills.git // 克隆远程库$ git remote rm origin // 删除远程库origin$ git fetch [remote] // 下载远程仓库的所有变动$ git remote -v // 显示所有远程仓库$ git remote show [remote] // 显示某个远程仓库的信息$ git remote add [shortname] [url] // 增加一个新的远程仓库，并命名$ git pull [remote] [branch] // 取回远程仓库的变化，并与本地分支合并$ git push [remote] [branch] // 上传本地指定分支到远程仓库$ git push [remote] --force // 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --all //推送所有分支到远程仓库 五、添加/删除文件1234567$ git add README.md //添加指定文件到暂存区$ git add -A //添加当前目录的所有文件到暂存区$ git rm README.md //删除工作区文件，并且将这次删除放入暂存区$ git mv [file-original] [file-renamed] //改名文件，并且将这个改名放入暂存区 六、代码提交12345678910111213141516171819202122$ git commit -m 'first commit' //提交暂存区到仓库区$ git commit -a //提交工作区自上次commit之后的变化，直接到仓库区$ git commit -v //提交时显示所有diff信息$ git commit --amend -m [message] //使用一次新的commit，替代上一次提交 //如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend [file1] [file2] //重做上一次commit，并包括指定文件的新变化``` 七、撤销修改---```bash$ git checkout [file] // 恢复暂存区的指定文件到工作区$ git checkout . // 恢复暂存区的所有文件到工作区 $ git reset [file] // 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset --hard // 重置暂存区与工作区，与上一次commit保持一致 八、分支1234567891011$ git branch // 列出所有本地分支$ git branch -r // 列出所有远程分支$ git branch -a // 列出所有本地分支和远程分支$ git branch [branch-name] // 新建一个分支，但依然停留在当前分支$ git checkout -b [branch] // 新建一个分支，并切换到该分支$ git merge [branch] // 合并指定分支到当前分支 九、查看信息123456789$ git status // 显示有变更的文件$ git log // 显示当前分支的版本历史$ git log --stat // 显示commit历史，以及每次commit发生变更的文件$ git diff //显示暂存区和工作区的差异$ git diff HEAD // 显示工作区与当前分支最新commit之间的差异]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript 6 学习笔记（三）：字符串、正则和数值的扩展]]></title>
      <url>%2F2016%2F12%2F25%2FECMAScript-6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%AD%A3%E5%88%99%E5%92%8C%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[字符串1.repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整。1234'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'dota'.repeat(0) // ""'dota'.repeat(2.9) // "dotadota" 2.模板字符串 模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，变量名写在${}之中。12345678`I sure $&#123;name&#125; is a good boy`$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 3.padStart()，padEnd() 字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 正则RegExp构造函数 ES512var regex = new RegExp('xyz', 'i');var regex = new RegExp(/xyz/i); ES6123var regex = /xyz/i;new RegExp(/abc/ig, 'i').flags// "i" 原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 数值1.Number.isFinite(), Number.isNaN() ES6 在 Number 对象上，新提供了 Number.isFinite() 和 Number.isNaN() 两个方法。Number.isFinite()用来检查一个数值是否为有限的（finite）1234Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // false Number.isNaN()用来检查一个值是否为 NaN。1234Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // false 2.Number.parseInt(), Number.parseFloat() ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 3.Number.isInteger() Number.isInteger()用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger("15") // falseNumber.isInteger(true) // false 4.Math 对象的扩展 Math.trunc() Math.trunc方法用于去除一个数的小数部分，返回整数部分1234567Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc('123.456') // 123 对于非数值，Math.trunc内部使用Number方法将其先转为数值。Math.trunc('foo'); // NaN 对于空值和无法截取整数的值，返回NaN。 Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零 它会返回五种值。 参数为正数，返回+1；参数为负数，返回-1；参数为0，返回0；参数为-0，返回-0;其他值，返回NaN。1234567Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign('foo'); // NaNMath.sign(); // NaN Math.cbrt() Math.cbrt方法用于计算一个数的立方根。123456Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734Math.cbrt('8') // 2 对于非数值，Math.cbrt内部使用Number方法将其先转为数值。Math.cbrt('hello') // NaN 对于空值和无法截取整数的值，返回NaN。 5.指数运算符 ES2016 新增了一个指数运算符（**）。122 ** 2 // 42 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript 6 学习笔记（二）：变量的解构赋值]]></title>
      <url>%2F2016%2F12%2F25%2FECMAScript-6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[1. 数组的解构赋值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 基本用法 ES6 可以从数组中提取值，按照对应位置，对变量赋值。1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。12345let [foo, [[bar], baz]] = [1, [[2], 3]]; // foo = 1 bar = 2 baz = 3let [ , , third] = ["foo", "bar", "baz"]; // third = "baz"let [x, , y] = [1, 2, 3]; // x = 1 y = 3 默认值 解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 2. 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 3. 字符串的解构赋值123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 4. 用途 交换变量的值123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript 6 学习笔记（一）：let / const 命令]]></title>
      <url>%2F2016%2F12%2F24%2FECMAScript-6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Alet-const-%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[前言 现在 ES6 已经非常普及了，基本上前端新出的框架都用上了ES6的语法。作为新兴时代的前端，如果你还对 ES6 不了解那就真的过分了，兄弟们赶紧撸起袖子搞起来吧！附上阮一峰写的书 ECMAScript 6 入门 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言 ECMAScript 和 JavaScript 的关系 ECMAScript 是 Javascript 的规范，Javascript 是 ECMAScript 的实现 声明的新方式 let / const 使用ES6，我们需要全面使用let/const替换var，我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量，也可以称之为常量。 1. let 不同于 var，let 声明的变量只在 let 命令所在的代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 for 循环的计数器，就很合适使用let命令 下面的代码使用 var 声明 i，console 里面的 i 是全局声明的，会随着循环而变化最后为 10，使得 a[0] , a[1] … a[9] 函数里面的 i 都是 10，所以最后 a6 结果也是 10 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 而使用 let 声明的变量仅在块级作用域内有效，如下，当前的 i 只在本轮循环有效，所以每一次 console 的 i 其实都是一个新的变量，所以输出是 6 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 let 不存在变量提升 var 声明的变量，可以在声明之前使用，值为undefind而 let 声明的变量一定要在声明后使用，否则报错1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'dota'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 不允许重复声明12345678910111213141516171819function () &#123; let a = 10; var a = 1;// 报错&#125;function () &#123; let a = 10; let a = 1;// 报错&#125;function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 2. 块级作用域 ES512345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; // if代码块内var变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 &#125;&#125;f(); // undefined ES61234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; // if代码块内声明了新的n变量，外层代码块不受内层代码块的影响 &#125; console.log(n); // 5&#125; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 3. const const声明一个只读的常量。一旦声明，常量的值就不能改变。123const COUNT = 10COUNT = 11;console.log(COUNT) //Uncaught TypeError: Assignment to constant variable. 对于const来说，只声明不赋值，就会报错。12const foo;// SyntaxError: Missing initializer in const declaration const 声明与 let 基本相同 只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升 同样存在暂时性死区，只能在声明的位置后面使用。 const声明的常量，也与let一样不可重复声明。 const本质 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心 12345678910111213141516const foo = &#123;&#125;;// 可以为 foo 添加一个属性foo.prop = 123;foo.prop // 123// 但是如果将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-onlyconst a = [];a.push("1")console.log(a) // ["1"]const a = [];a = [1,2,3]console.log(a) // 报错 4. 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 ES6一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。12345var a = 1;window.a // 1let b = 1;window.b // undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cmd Markdown 编辑阅读器]]></title>
      <url>%2F2016%2F12%2F14%2FCmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
      <content type="text"><![CDATA[我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
